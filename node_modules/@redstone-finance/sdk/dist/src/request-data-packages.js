"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.requestDataPackages = exports.calculateHistoricalPackagesTimestamp = exports.getDataServiceIdForSigner = void 0;
const protocol_1 = require("@redstone-finance/protocol");
const utils_1 = require("@redstone-finance/utils");
const axios_1 = __importDefault(require("axios"));
const zod_1 = require("zod");
const data_services_urls_1 = require("./data-services-urls");
const GET_REQUEST_TIMEOUT = 5000;
const DEFAULT_WAIT_FOR_ALL_GATEWAYS_TIME = 500;
const MILLISECONDS_IN_ONE_MINUTE = 60 * 1000;
const GwResponseSchema = zod_1.z.record(zod_1.z.string(), zod_1.z.array(zod_1.z.object({
    dataPoints: zod_1.z
        .array(zod_1.z
        .object({
        dataFeedId: zod_1.z.string(),
        value: zod_1.z.number(),
        decimals: zod_1.z.number().optional(),
    })
        .or(zod_1.z.object({
        dataFeedId: zod_1.z.string(),
        value: zod_1.z.string(),
        decimals: zod_1.z.number().optional(),
    })))
        .min(1),
    timestampMilliseconds: zod_1.z.number(),
    signature: zod_1.z.string(),
    dataFeedId: zod_1.z.string(),
})));
const getDataServiceIdForSigner = (oracleState, signerAddress) => {
    for (const nodeDetails of Object.values(oracleState.nodes)) {
        if (nodeDetails.evmAddress.toLowerCase() === signerAddress.toLowerCase()) {
            return nodeDetails.dataServiceId;
        }
    }
    throw new Error(`Data service not found for ${signerAddress}`);
};
exports.getDataServiceIdForSigner = getDataServiceIdForSigner;
const calculateHistoricalPackagesTimestamp = (deviationCheckOffsetInMinutes, baseTimestamp = Date.now()) => {
    if (deviationCheckOffsetInMinutes > 0) {
        return (Math.floor(baseTimestamp / MILLISECONDS_IN_ONE_MINUTE -
            deviationCheckOffsetInMinutes) * MILLISECONDS_IN_ONE_MINUTE);
    }
    return undefined;
};
exports.calculateHistoricalPackagesTimestamp = calculateHistoricalPackagesTimestamp;
const requestDataPackages = async (reqParams) => {
    if (reqParams.dataFeeds.length < 1) {
        throw new Error("Please provide at least one dataFeed");
    }
    try {
        const promises = prepareDataPackagePromises(reqParams);
        if (reqParams.historicalTimestamp) {
            return await Promise.any(promises);
        }
        return await getTheMostRecentDataPackages(promises, reqParams.waitForAllGatewaysTimeMs);
    }
    catch (e) {
        const errMessage = `Request failed ${JSON.stringify({
            reqParams,
        })}, Original error: ${utils_1.RedstoneCommon.stringifyError(e)}`;
        throw new Error(errMessage);
    }
};
exports.requestDataPackages = requestDataPackages;
const getTheMostRecentDataPackages = (promises, waitForAllGatewaysTimeMs = DEFAULT_WAIT_FOR_ALL_GATEWAYS_TIME) => {
    return new Promise((resolve, reject) => {
        const collectedResponses = [];
        const errors = [];
        let waitForAll = true;
        const timer = setTimeout(() => {
            waitForAll = false;
            checkResults();
        }, waitForAllGatewaysTimeMs);
        const checkResults = () => {
            if (errors.length === promises.length) {
                clearTimeout(timer);
                reject(new AggregateError(errors));
            }
            else if (collectedResponses.length + errors.length === promises.length ||
                (!waitForAll && collectedResponses.length !== 0)) {
                const newestPackage = collectedResponses.reduce((a, b) => {
                    const aTimestamp = Object.values(a).at(0)?.at(0)?.dataPackage.timestampMilliseconds ??
                        0;
                    const bTimestamp = Object.values(b).at(0)?.at(0)?.dataPackage.timestampMilliseconds ??
                        0;
                    return bTimestamp > aTimestamp ? b : a;
                });
                clearTimeout(timer);
                resolve(newestPackage);
            }
        };
        for (const promise of promises) {
            promise
                .then((r) => collectedResponses.push(r))
                .catch((e) => errors.push(e))
                .finally(checkResults);
        }
    });
};
const prepareDataPackagePromises = (reqParams) => {
    if (reqParams.authorizedSigners && reqParams.authorizedSigners.length == 0) {
        throw new Error("authorizer signers array, if provided, cannot be empty");
    }
    const urls = getUrlsForDataServiceId(reqParams);
    const pathComponents = [
        "data-packages",
        reqParams.historicalTimestamp ? "historical" : "latest",
        reqParams.dataServiceId,
    ];
    if (reqParams.historicalTimestamp) {
        pathComponents.push(`${reqParams.historicalTimestamp}`);
    }
    return urls.map((url) => sendRequestToGateway(url, pathComponents, reqParams).then((response) => parseAndValidateDataPackagesResponse(response.data, reqParams)));
};
const parseAndValidateDataPackagesResponse = (responseData, reqParams) => {
    const parsedResponse = {};
    utils_1.RedstoneCommon.zodAssert(GwResponseSchema, responseData);
    const requestedDataFeedIds = reqParams.dataFeeds;
    for (const dataFeedId of requestedDataFeedIds) {
        let dataFeedPackages = responseData[dataFeedId];
        if (!dataFeedPackages) {
            throw new Error(`Requested data feed id is not included in response: ${dataFeedId}`);
        }
        if (reqParams.authorizedSigners) {
            dataFeedPackages = dataFeedPackages.filter((dp) => {
                const signer = maybeGetSigner(dp);
                if (!signer) {
                    return false;
                }
                return reqParams.authorizedSigners.includes(signer);
            });
        }
        if (reqParams.maxTimestampDeviationMS) {
            const now = Date.now();
            dataFeedPackages = dataFeedPackages.filter((dp) => Math.abs(now - dp.timestampMilliseconds) <
                reqParams.maxTimestampDeviationMS);
        }
        if (dataFeedPackages.length < reqParams.uniqueSignersCount) {
            throw new Error(`Too few unique signers for the data feed: ${dataFeedId}. ` +
                `Expected: ${reqParams.uniqueSignersCount}. ` +
                `Received: ${dataFeedPackages.length}`);
        }
        parsedResponse[dataFeedId] = pickDataFeedPackagesClosestToMedian(dataFeedPackages, reqParams.uniqueSignersCount);
    }
    return parsedResponse;
};
const pickDataFeedPackagesClosestToMedian = (dataFeedPackages, count) => {
    const median = utils_1.MathUtils.getMedian(dataFeedPackages.map((dp) => dp.dataPoints[0].value));
    return sortByDistanceFromMedian(dataFeedPackages, median)
        .map((diff) => protocol_1.SignedDataPackage.fromObj(diff.dp))
        .slice(0, count);
};
function sendRequestToGateway(url, pathComponents, reqParams) {
    const sanitizedUrl = [url.replace(/\/+$/, "")]
        .concat(pathComponents)
        .join("/");
    return axios_1.default.get(sanitizedUrl, {
        timeout: GET_REQUEST_TIMEOUT,
        params: {
            dataFeedIds: reqParams.dataFeeds,
            minimalSignersCount: reqParams.uniqueSignersCount,
        },
        paramsSerializer: { indexes: null },
    });
}
function maybeGetSigner(dp) {
    try {
        return protocol_1.SignedDataPackage.fromObj(dp).recoverSignerAddress();
    }
    catch {
        return undefined;
    }
}
function sortByDistanceFromMedian(dataFeedPackages, median) {
    return dataFeedPackages
        .map((dp) => ({
        dp: dp,
        diff: utils_1.SafeNumber.createSafeNumber(dp.dataPoints[0].value)
            .sub(median)
            .abs(),
    }))
        .sort((first, second) => first.diff.sub(second.diff).unsafeToNumber());
}
const getUrlsForDataServiceId = (reqParams) => {
    if (reqParams.urls) {
        return reqParams.urls;
    }
    return (0, data_services_urls_1.resolveDataServiceUrls)(reqParams.dataServiceId);
};
//# sourceMappingURL=request-data-packages.js.map