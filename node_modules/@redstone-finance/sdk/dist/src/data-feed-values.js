"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.aggregateValues = exports.getDataFeedValues = void 0;
const utils_1 = require("@redstone-finance/utils");
const axios_1 = __importDefault(require("axios"));
const data_services_urls_1 = require("./data-services-urls");
const DEFAULT_DATA_SERVICE_ID = "redstone-main-demo";
const DEFAULT_AGGREGATION_ALGORITHM = "median";
const getDataFeedValues = async (args = {}) => {
    const dataServiceId = args.dataServiceId ?? DEFAULT_DATA_SERVICE_ID;
    const aggregationAlgorithm = args.aggregationAlgorithm ?? DEFAULT_AGGREGATION_ALGORITHM;
    const gatewayUrls = args.gatewayUrls ?? (0, data_services_urls_1.resolveDataServiceUrls)(dataServiceId);
    const dataPackagesPerFeed = await Promise.any(gatewayUrls.map((url) => getDataPackagesFromGateway(url, dataServiceId)));
    const result = {};
    for (const [dataFeedId, dataPackages] of Object.entries(dataPackagesPerFeed)) {
        const plainValues = dataPackages
            .filter((dp) => dp.dataPoints.length === 1)
            .map((dp) => Number(dp.dataPoints[0].value));
        if (plainValues.length === 0) {
            continue;
        }
        result[dataFeedId] = (0, exports.aggregateValues)(plainValues, aggregationAlgorithm);
    }
    return result;
};
exports.getDataFeedValues = getDataFeedValues;
const getDataPackagesFromGateway = async (url, dataServiceId) => {
    const response = await axios_1.default.get(`${url}/data-packages/latest/${dataServiceId}`);
    if (typeof response.data === "string") {
        throw new Error(`Failed to fetch data package from ${url}. Data service ID responded with: ${String(response.data)}`);
    }
    return response.data;
};
const aggregateValues = (plainValues, aggregationAlgorithm) => {
    switch (aggregationAlgorithm) {
        case "max":
            return Math.max(...plainValues);
        case "min":
            return Math.min(...plainValues);
        case "median":
            return utils_1.MathUtils.getMedian(plainValues);
        default:
            throw new Error(`Unsupported aggregationAlgorithm ${String(aggregationAlgorithm)}`);
    }
};
exports.aggregateValues = aggregateValues;
//# sourceMappingURL=data-feed-values.js.map